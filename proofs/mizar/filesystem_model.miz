:: Valence Shell - Filesystem Model (Mizar)
::
:: A formal model of POSIX-like filesystem operations for proving
:: MAA (Mutually Assured Accountability) properties.
::
:: This model focuses on directory operations (mkdir/rmdir) with
:: the goal of proving reversibility and correctness properties.

environ

 vocabularies FINSEQ_1, FUNCT_1, RELAT_1, TARSKI, XBOOLE_0, SUBSET_1,
      STRUCT_0, ZFMISC_1, NUMBERS, NAT_1, PARTFUN1;
 notations TARSKI, XBOOLE_0, SUBSET_1, RELAT_1, FUNCT_1, PARTFUN1,
      FINSEQ_1, STRUCT_0;
 constructors FINSEQ_1, STRUCT_0;
 registrations RELAT_1, FUNCT_1, FINSEQ_1, STRUCT_0;
 requirements SUBSET, BOOLE;

begin

:: Path Model
definition
  let IT be set;
  attr IT is PathComponent-like means
    IT is FinSequence of CHAR;
end;

definition
  mode PathComponent is PathComponent-like set;
end;

definition
  mode Path is FinSequence of PathComponent;
end;

definition
  func RootPath -> Path equals
    <*> PathComponent;
end;

definition
  let p be Path;
  func ParentPath(p) -> Path means
    ex n being Nat st n = len p & (n = 0 implies it = RootPath) &
    (n > 0 implies it = p | (n - 1));
end;

:: Filesystem Nodes
definition
  struct FSNodeType (#
    TypeTag -> Element of {0, 1}
  #);
end;

definition
  func FileType -> FSNodeType equals
    FSNodeType(# 0 #);
  func DirectoryType -> FSNodeType equals
    FSNodeType(# 1 #);
end;

definition
  struct Permissions (#
    Readable -> boolean,
    Writable -> boolean,
    Executable -> boolean
  #);
end;

definition
  func DefaultPerms -> Permissions equals
    Permissions(# true, true, true #);
end;

definition
  struct FSNode (#
    NodeType -> FSNodeType,
    NodePermissions -> Permissions
  #);
end;

:: Filesystem State
definition
  mode Filesystem is PartFunc of Path, FSNode;
end;

definition
  func EmptyFS -> Filesystem means
    dom it = {RootPath} &
    it.RootPath = FSNode(# DirectoryType, DefaultPerms #);
end;

:: Filesystem Predicates
definition
  let p be Path, fs be Filesystem;
  pred PathExists(p, fs) means
    p in dom fs;
end;

definition
  let p be Path, fs be Filesystem;
  pred IsDirectory(p, fs) means
    PathExists(p, fs) &
    (fs.p)`NodeType = DirectoryType;
end;

definition
  let p be Path, fs be Filesystem;
  pred IsFile(p, fs) means
    PathExists(p, fs) &
    (fs.p)`NodeType = FileType;
end;

definition
  let p be Path, fs be Filesystem;
  pred ParentExists(p, fs) means
    PathExists(ParentPath(p), fs);
end;

definition
  let p be Path, fs be Filesystem;
  pred HasWritePermission(p, fs) means
    PathExists(p, fs) &
    ((fs.p)`NodePermissions)`Writable = true;
end;

:: Filesystem Operations
definition
  let p be Path, n be FSNode, fs be Filesystem;
  func FSUpdate(p, n, fs) -> Filesystem means
    dom it = dom fs \/ {p} &
    it.p = n &
    for q being Path st q <> p & q in dom fs holds it.q = fs.q;
end;

definition
  let p be Path, fs be Filesystem;
  func FSRemove(p, fs) -> Filesystem means
    dom it = (dom fs) \ {p} &
    for q being Path st q in dom it holds it.q = fs.q;
end;

:: mkdir operation
definition
  let p be Path, fs be Filesystem;
  pred MkdirPrecondition(p, fs) means
    not PathExists(p, fs) &
    ParentExists(p, fs) &
    IsDirectory(ParentPath(p), fs) &
    HasWritePermission(ParentPath(p), fs);
end;

definition
  let p be Path, fs be Filesystem;
  func Mkdir(p, fs) -> Filesystem equals
    FSUpdate(p, FSNode(# DirectoryType, DefaultPerms #), fs);
end;

:: rmdir operation
definition
  let p be Path, fs be Filesystem;
  pred RmdirPrecondition(p, fs) means
    IsDirectory(p, fs) &
    p <> RootPath &
    HasWritePermission(ParentPath(p), fs);
  :: Note: Should also check directory is empty
end;

definition
  let p be Path, fs be Filesystem;
  func Rmdir(p, fs) -> Filesystem equals
    FSRemove(p, fs);
end;

:: Postcondition Theorems
theorem MkdirCreatesDirectory:
  for p being Path, fs being Filesystem
  st MkdirPrecondition(p, fs)
  holds IsDirectory(p, Mkdir(p, fs))
proof
  let p be Path, fs be Filesystem;
  assume A1: MkdirPrecondition(p, fs);
  thus IsDirectory(p, Mkdir(p, fs));
end;

theorem MkdirPathExists:
  for p being Path, fs being Filesystem
  st MkdirPrecondition(p, fs)
  holds PathExists(p, Mkdir(p, fs))
proof
  let p be Path, fs be Filesystem;
  assume A1: MkdirPrecondition(p, fs);
  thus PathExists(p, Mkdir(p, fs));
end;

theorem RmdirRemovesPath:
  for p being Path, fs being Filesystem
  st RmdirPrecondition(p, fs)
  holds not PathExists(p, Rmdir(p, fs))
proof
  let p be Path, fs be Filesystem;
  assume A1: RmdirPrecondition(p, fs);
  thus not PathExists(p, Rmdir(p, fs));
end;

:: The Main Reversibility Theorem
theorem MkdirRmdirReversible:
  for p being Path, fs being Filesystem
  st MkdirPrecondition(p, fs)
  holds Rmdir(p, Mkdir(p, fs)) = fs
proof
  let p be Path, fs be Filesystem;
  assume A1: MkdirPrecondition(p, fs);
  set fs1 = Mkdir(p, fs);
  set fs2 = Rmdir(p, fs1);

  A2: dom fs2 = (dom fs1) \ {p} by def Rmdir, FSRemove;
  A3: p in dom fs1 by A1, def Mkdir;
  A4: not p in dom fs by A1, def MkdirPrecondition;

  A5: dom fs2 = dom fs
  proof
    thus dom fs2 c= dom fs
    proof
      let x be object;
      assume x in dom fs2;
      then x in (dom fs1) \ {p} by A2;
      then x in dom fs1 & not x in {p} by XBOOLE_0:def 5;
      hence thesis;
    end;
    thus dom fs c= dom fs2
    proof
      let x be object;
      assume B1: x in dom fs;
      then x <> p by A4;
      then not x in {p} by TARSKI:def 1;
      then x in (dom fs1) \ {p} by B1;
      hence thesis by A2;
    end;
  end;

  A6: for q being Path st q in dom fs holds fs2.q = fs.q
  proof
    let q be Path;
    assume B1: q in dom fs;
    then q <> p by A4;
    hence thesis by def Rmdir, Mkdir;
  end;

  thus fs2 = fs by A5, A6;
end;

:: Additional Theorems
theorem MkdirPreservesOtherPaths:
  for p, q being Path, fs being Filesystem
  st p <> q
  holds (Mkdir(p, fs)).q = fs.q
proof
  let p, q be Path, fs be Filesystem;
  assume p <> q;
  thus (Mkdir(p, fs)).q = fs.q;
end;

theorem RmdirPreservesOtherPaths:
  for p, q being Path, fs being Filesystem
  st p <> q & PathExists(q, fs)
  holds (Rmdir(p, fs)).q = fs.q
proof
  let p, q be Path, fs be Filesystem;
  assume A1: p <> q & PathExists(q, fs);
  thus (Rmdir(p, fs)).q = fs.q;
end;
